**1. 计算属性闭包**

给定 \(R(A,B,C,D,E)\)，函数依赖集  
\[
F = \{\,AB\to C,\;B\to CD,\;DE\to B,\;C\to D,\;D\to A\}.
\]

我们逐一计算 \((AB)^+\)、\((AC)^+\)、\((DE)^+\)，并写出完整推导步骤。

---

#### （1）\((AB)^+\)

1. 初始：\(\{A,B\}\).  
2. 用 \(AB\to C\)，得到 \(\{A,B,C\}\).  
3. 用 \(B\to CD\)，由 \(B\) 得到 \(C,D\)，于是闭包扩展为 \(\{A,B,C,D\}\).  
4. 用 \(C\to D\)、\(D\to A\)，并无新属性。  
5. \(DE\to B\) 需 \(E\)，此时无 \(E\)。

\[
\boxed{(AB)^+ = \{A,B,C,D\}}
\]

---

#### （2）\((AC)^+\)

1. 初始：\(\{A,C\}\).  
2. 用 \(C\to D\)，得到 \(\{A,C,D\}\).  
3. 用 \(D\to A\)，无新属性。  
4. 余下依赖都需 \(B\) 或 \(E\)，无法使用。

\[
\boxed{(AC)^+ = \{A,C,D\}}
\]

---

#### （3）\((DE)^+\)

1. 初始：\(\{D,E\}\).  
2. 用 \(DE\to B\)，得到 \(\{B,D,E\}\).  
3. 用 \(B\to CD\)，加入 \(C\)（\(D\) 已有）：\(\{B,C,D,E\}\).  
4. 用 \(C\to D\)、\(D\to A\)，加入 \(A\)：\(\{A,B,C,D,E\}\).  
5. 其余依赖均已涵盖。

\[
\boxed{(DE)^+ = \{A,B,C,D,E\}}
\]

---

**2. 设计满足 3NF 的模式**

给定 \(R(A,B,C,D,E,I)\)，函数依赖集  
\[
F = \{\,A\to BD,\;EC\to D,\;C\to I,\;ID\to CE,\;AI\to D,\;B\to A\}.
\]

我们按以下步骤进行：

---

### 2.1 求最小函数依赖集（Minimal Cover）

1. **原子化（分解右部）**  
   \[
   \begin{aligned}
   &A\to B,\quad A\to D,\\
   &EC\to D,\\
   &C\to I,\\
   &ID\to C,\quad ID\to E,\\
   &AI\to D,\\
   &B\to A.
   \end{aligned}
   \]
2. **去除冗余 FD**  
   - **\(AI\to D\)**：因已含 \(A\to D\)，故冗余，去掉。  
   - **对每个 FD 考察左部属性的可去除性**  
     - \(ID\to C\) 和 \(ID\to E\) 中都无法去掉任一属性。  
     - \(EC\to D\) 中 \(E\)、\(C\) 都不可去除。  
     - 其余皆为单属性左部，无法再简化。  
3. **结果——最小函数依赖集**  
   \[
   F_{\min} = \{\,A\to B,\;A\to D,\;EC\to D,\;C\to I,\;ID\to C,\;ID\to E,\;B\to A\}.
   \]

---

### 2.2 计算候选键

属性全集 \(\{A,B,C,D,E,I\}\)。我们尝试求闭包，看哪些组合能覆盖全集。

- **\(\{A,I\}^+\)**  
  1. 初始：\(\{A,I\}\).  
  2. \(A\to B,D\) → \(\{A,B,D,I\}\).  
  3. \(ID\to C,E\) → \(\{A,B,C,D,E,I\}\).  
  4. 其余依赖均已涵盖。  
  \(\therefore\{A,I\}\) 是超键，且无真子集能覆盖全集，故为候选键。

- **\(\{B,I\}^+\)**  
  1. 初始：\(\{B,I\}\).  
  2. \(B\to A\) → \(\{A,B,I\}\).  
  3. \(A\to D\) → \(\{A,B,D,I\}\).  
  4. \(ID\to C,E\) → 全集。  
  故 \(\{B,I\}\) 也是候选键。

其他组合要么不能覆盖全集，要么包含以上二者的超集。

> **候选键**：\(\{A,I\}\) 与 \(\{B,I\}\)。

---

### 2.3 基于每个依赖构造 3NF 分解

对 \(F_{\min}\) 中的每个 FD \(X\to Y\)，构造关系模式 \(R_{XY}(X\cup Y)\)：

| FD        | 模式                    |
|:---------:|:-----------------------:|
| \(A\to B\)   | \(R_1(A,B)\)           |
| \(A\to D\)   | \(R_2(A,D)\)           |
| \(EC\to D\)  | \(R_3(E,C,D)\)         |
| \(C\to I\)   | \(R_4(C,I)\)           |
| \(ID\to C\)  | \(R_5(I,D,C)\)         |
| \(ID\to E\)  | \(R_6(I,D,E)\)         |
| \(B\to A\)   | \(R_7(B,A)\)           |

- **合并或剔除冗余**  
  - \(R_1(A,B)\) 与 \(R_7(B,A)\) 相同，合并为 \(R_{AB}(A,B)\)。  
  - \(R_5(I,D,C)\) 与 \(R_6(I,D,E)\) 可合并为 \(R_{IDCE}(I,D,C,E)\)，此时也包含了依赖 \(ID\to CE\)、\(EC\to D\)、\(C\to I\)、以及通过 \(ID\to C\) 与 \(ID\to E\) 与 \(C\to I\) 的推导。  
  - \(R_3(E,C,D)\) 与 \(R_{IDCE}\) 的属性集一致或被包含，可剔除；\(R_4(C,I)\) 亦被包含。  
  - 为保证候选键 \(\{A,I\}\)（或 \(\{B,I\}\)）出现在某个模式的属性集中，我们保留 \(R_{AI}(A,I)\)。

> **最终 3NF 分解：**  
> \[
> \begin{aligned}
> &R_{AB}(A,B),\\
> &R_{AD}(A,D),\\
> &R_{AI}(A,I),\\
> &R_{IDCE}(I,D,C,E).
> \end{aligned}
> \]
>
> - **依赖保留**：每个原始 FD 都在某个子模式中得以体现。  
> - **无损连接**：各子模式中至少有一个包含原关系的候选键（\(\{A,I\}\subseteq R_{AI}\)），保证无损。  
> - **每个子模式均为 3NF**，因为在各自的模式中，右部要么是主属性，要么左部是超键。